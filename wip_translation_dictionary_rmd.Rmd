---
title: "WIP MADC Data Unification"
author: "Nicolas May"
date: "1/7/2019"
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    theme: sandstone
    highlight: zenburn
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load Requirements

## Load Useful Libraries

```{r}
# USEFUL LIBRARIES ----
library(dplyr)
library(stringr)
library(knitr)
library(kableExtra)
```

## Load Useful Variables

```{r}
# USEFUL VARS ----
source('~/Box Sync/Documents/R_helpers/config.R')
rm(BOX_CLIENT_ID); rm(BOX_CLIENT_SECRET); rm(BOX_REDIRECT_URI)
rm(REDCAP_DATA_REQUESTS_TOKEN)
source('~/Box Sync/Documents/R_helpers/helpers.R')

## switch to access API (TRUE) or not (FALSE)
GET_API_DATA <- TRUE
```

## Load Useful Helper Functions

```{r}
# USEFUL HELPER FUNCTIONS ----
remove_NAs <- function(x) {
  if (!is.vector(x)) { stop('x is not a vector') }
  x[!is.na(x)]
}
```


# Get Data

## Get REDCap Project Data Fields

### UDS 2
```{r}
# _ UDS 2 ----
if (GET_API_DATA) {
  export_fields_u2_json <- RCurl::postForm(
    uri=REDCAP_API_URI,
    token=REDCAP_API_TOKEN_UDS2,
    content='exportFieldNames',
    format='json',
    returnFormat='json',
    .opts = list(ssl.verifypeer = FALSE) # using linux
  )
}
export_fields_u2_df <- jsonlite::fromJSON(export_fields_u2_json) %>% 
  na_if('')
readr::write_csv(export_fields_u2_df, 
                 "Export Fields/export_fields_u2_df.csv", na = "")
head(export_fields_u2_df) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

### UDS 3 Archive
```{r}
# _ UDS 3 (Archive) ----
if (GET_API_DATA) {
  export_fields_u3a_json <- RCurl::postForm(
    uri=REDCAP_API_URI,
    token=REDCAP_API_TOKEN_UDS3a,
    content='exportFieldNames',
    format='json',
    returnFormat='json',
    .opts = list(ssl.verifypeer = FALSE) # using linux
  )
}
export_fields_u3a_df <- jsonlite::fromJSON(export_fields_u3a_json) %>% 
  na_if('')
readr::write_csv(export_fields_u3a_df, 
                 "Export Fields/export_fields_u3a_df.csv", na = "")
head(export_fields_u3a_df) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

### UDS 3 New
```{r}
# _ UDS 3 (New) ----
if (GET_API_DATA) {
  export_fields_u3n_json <- RCurl::postForm(
    uri=REDCAP_API_URI,
    token=REDCAP_API_TOKEN_UDS3n,
    content='exportFieldNames',
    format='json',
    returnFormat='json',
    .opts = list(ssl.verifypeer = FALSE) # using linux
  )
}
export_fields_u3n_df <- jsonlite::fromJSON(export_fields_u3n_json) %>% 
  na_if('')
readr::write_csv(export_fields_u3n_df, 
                 "Export Fields/export_fields_u3n_df.csv", na = "")
head(export_fields_u3n_df) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

### MiNDSet Registry
```{r}
# _ MiNDSet ----
if (GET_API_DATA) {
  export_fields_ms_json <- RCurl::postForm(
    uri=REDCAP_API_URI,
    token=REDCAP_API_TOKEN_MINDSET,
    content='exportFieldNames',
    format='json',
    returnFormat='json',
    .opts = list(ssl.verifypeer = FALSE) # using linux
  )
}
export_fields_ms_df <- jsonlite::fromJSON(export_fields_ms_json) %>% 
  na_if('')
readr::write_csv(export_fields_ms_df,
                 "Export Fields/export_fields_ms_df.csv", na = "")
head(export_fields_ms_df) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

## Get Human-Resolved Fields 

Because there are asystematic mismatches between the three UDS datsets that MADC has stored in REDCap, there are two XLSX files that require human creation/maintenance. Loading and processing the data in the files makes it possible to resolve field name mismatches in order to harmonize and unify the data.

```{r}
# _ Get work-in-progress translation dictionary ----
trans_dict <- readxl::read_excel('WIP__translation_dictionary.xlsx')
head(trans_dict) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)

# _ Get work-in-progress UDS3 ivp-fvp-tvp matches ----
u3n_ift_match <- readxl::read_excel('WIP__uds3_ift_matches.xlsx') %>% 
  select(field_ivp, form_ivp, 
         field_fvp, form_fvp,
         field_tvp, form_tvp)
head(u3n_ift_match) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

## Process Dataset Fields

### UDS 2
```{r}
# _ UDS 2 ----
fields_u2_raw <- trans_dict$field_u2
fields_u2_raw <- remove_NAs(fields_u2_raw)
fields_u2 <- fields_u2_raw %>% paste(collapse = ',')
```

### UDS 3 Archive
```{r}
# _ UDS 3 (Archive) ----
fields_u3a_raw <- trans_dict$field_u3a
fields_u3a_raw <- remove_NAs(fields_u3a_raw)
fields_u3a <- fields_u3a_raw %>% paste(collapse = ',')
```

### UDS 3 New

The fields for UDS 3 (New) require a little more work because there are three packets to collect participant data:

1. initial visit, IVP
2. follow-up visit, FVP
3. telephone visit, TVP

```{r}
# _ UDS 3 (New) ----
# _ _ IVP
fields_u3n_raw_i <- trans_dict$field_u3n
# _ _ FVP
fields_u3n_raw_fu <- u3n_ift_match %>% 
  filter(field_ivp %in% fields_u3n_raw_i) %>% 
  filter(!is.na(field_fvp)) %>% 
  pull(field_fvp)
# _ _ TVP
fields_u3n_raw_tele <- u3n_ift_match %>% 
  filter(field_ivp %in% fields_u3n_raw_i) %>% 
  filter(!is.na(field_tvp)) %>%
  pull(field_tvp)
# _ _ IVP + FVP + TVP
fields_u3n_raw <- c(fields_u3n_raw_i
                    , fields_u3n_raw_fu
                    , fields_u3n_raw_tele)
fields_u3n_raw <- remove_NAs(fields_u3n_raw) # remove NAs
fields_u3n <- fields_u3n_raw %>% paste(collapse = ',') 
```

## REDCap API Data Retrieval

### UDS 2
```{r}
# _ UDS 2 ----
if (GET_API_DATA) {
  json_u2 <- RCurl::postForm(
    uri=REDCAP_API_URI,
    token=REDCAP_API_TOKEN_UDS2,
    content='record',
    format='json',
    type='flat',
    fields=fields_u2,
    rawOrLabel='raw',
    rawOrLabelHeaders='raw',
    exportCheckboxLabel='false',
    exportSurveyFields='false',
    exportDataAccessGroups='false',
    returnFormat='json',
    .opts = list(ssl.verifypeer = FALSE) # using linux
  )
  json_u2 <- str_replace_all(json_u2, "\r\n", " ")
}
df_u2 <- jsonlite::fromJSON(json_u2) %>% na_if('')
# # Clean out '___1' from field some field names -- Generalize later
# names(df_u2) <- str_replace(names(df_u2), 
#                             pattern = "___1", 
#                             replacement = "")
```

### UDS 3 Archive
```{r}
# _ UDS 3 (Archive) ----
if (GET_API_DATA) {
  json_u3a <- RCurl::postForm(
    uri=REDCAP_API_URI,
    token=REDCAP_API_TOKEN_UDS3a,
    content='record',
    format='json',
    type='flat',
    fields=fields_u3a,
    rawOrLabel='raw',
    rawOrLabelHeaders='raw',
    exportCheckboxLabel='false',
    exportSurveyFields='false',
    exportDataAccessGroups='false',
    returnFormat='json',
    .opts = list(ssl.verifypeer = FALSE) # using linux
  )
  json_u3a <- str_replace_all(json_u3a, "\r\n", " ")
}
df_u3a <- jsonlite::fromJSON(json_u3a) %>% na_if('')
```

### UDS 3 New
```{r}
# _ UDS 3 (New) ----
if (GET_API_DATA) {
  json_u3n <- RCurl::postForm(
    uri=REDCAP_API_URI,
    token=REDCAP_API_TOKEN_UDS3n,
    content='record',
    format='json',
    type='flat',
    fields=fields_u3n,
    rawOrLabel='raw',
    rawOrLabelHeaders='raw',
    exportCheckboxLabel='false',
    exportSurveyFields='false',
    exportDataAccessGroups='false',
    returnFormat='json',
    .opts = list(ssl.verifypeer = FALSE) # using linux
  )
  json_u3n <- str_replace_all(json_u3n, "\r\n", " ")
}
df_u3n <- jsonlite::fromJSON(json_u3n) %>% na_if('')

# Clean out Double Data Entry (DDE) records ending in "--1" or "--2"
df_u3n <- df_u3n %>% 
  filter(!(str_detect(ptid, "--1$|--2$")))
```

## Write Raw Data To CSV

This comes in handy when diagnosising and resolving possible code errors.

```{r}
readr::write_csv(df_u2, './Raw Data/df_u2.csv', na = '')
readr::write_csv(df_u3a, './Raw Data/df_u3a.csv', na = '')
readr::write_csv(df_u3n, './Raw Data/df_u3n.csv', na = '')
```


# Restructure Data

Since the UDS 3 (New) strcuture will be the standard template for all unified MADC UDS data, both UDS 2 and UDS 3 (Archive) need to be restructured to match the structure of UDS 3 (New), viz., the IVP/FVP/TVP format.

## UDS 3 (New) Data Structure As Standard

### UDS 2
```{r}
# IVP/FVP/TVP TRANSFORM (UDS 2, UDS 3 Archive) ----

# _ UDS 2 ----
# _ _ UDS 2 IVP ----
df_u2_i <- df_u2 %>% 
  filter(a1pkt_type == 'I')
# _ _ UDS 2 FVP ----
u3n_fvp_vars <- str_replace(fields_u3n_raw_fu, '^fu_|^fu', '')
u2_fvp_vars <- trans_dict %>% 
  filter(field_u3n %in% u3n_fvp_vars) %>% 
  pull(field_u2) %>% 
  remove_NAs(.)
df_u2_f <- df_u2 %>%
  filter(a1pkt_type == 'F') %>%
  rename_at(.vars = vars(one_of(u2_fvp_vars)),
            .funs = funs(str_replace(., '(.*)', 'fu_\\1')))
# _ _ UDS 2 TVP ----
u3n_tvp_vars <- str_replace(fields_u3n_raw_tele, 'tele_', '')
u2_tvp_vars <- trans_dict %>% 
  filter(field_u3n %in% u3n_tvp_vars) %>% 
  pull(field_u2) %>% 
  remove_NAs(.)
df_u2_t <- df_u2 %>% 
  filter(a1pkt_type == 'T') %>% 
  rename_at(.vars = vars(one_of(u2_tvp_vars)),
            .funs = funs(str_replace(., '(.*)', 'tele_\\1')))
# _ _ Row bind UDS 2 I+F+T ----
df_u2_ift <- bind_rows(df_u2_i, df_u2_f, df_u2_t)
```

### UDS 3 (Archive)
```{r}
# IVP/FVP/TVP TRANSFORM (UDS 2, UDS 3 Archive) ----

# _ UDS 3 (Archive) ----
# _ _ UDS 3 (Archive) IVP ----
df_u3a_i <- df_u3a %>% 
  filter(a1pkt_type == 'I')
# _ _ UDS 3 (Archive) FVP ----
u3n_fvp_vars <- str_replace(fields_u3n_raw_fu, 'fu_', '')
u3a_fvp_vars <- trans_dict %>% 
  filter(field_u3n %in% u3n_fvp_vars) %>% 
  pull(field_u3a) %>% 
  remove_NAs(.)
df_u3a_f <- df_u3a %>% 
  filter(a1pkt_type == 'F') %>% 
  rename_at(.vars = vars(one_of(u3a_fvp_vars)),
            .funs = funs(str_replace(., '(.*)', 'fu_')))
# _ _ UDS 3 (Archive) TVP ----
u3n_tvp_vars <- str_replace(fields_u3n_raw_tele, 'tele_', '')
u3a_tvp_vars <- trans_dict %>% 
  filter(field_u3n %in% u3n_tvp_vars) %>% 
  pull(field_u3a) %>% 
  remove_NAs(.)
df_u3a_t <- df_u3a %>% 
  filter(a1pkt_type == 'T') %>% 
  rename_at(.vars = vars(one_of(u3a_tvp_vars)),
            .funs = funs(str_replace(., '(.*)', 'tele_')))
# _ _ Row bind UDS 3 (Archive) I+F+T ----
df_u3a_ift <- bind_rows(df_u3a_i, df_u3a_f, df_u3a_t)
```

# Stitch Data Together

Based on the translation dictionary (`WIP__translation_dictionary.xlsx`), we'll stitch together all the UDS data into one harmonized dataset.

## Build Standard Names DF (`std_names_df`)

### Set up the empty df

```{r}
# _ Build standard names df ----
## Set up empty df
std_names_df <- data.frame(matrix(data = NA_character_,
                                  nrow = 0,
                                  ncol = 2),
                           stringsAsFactors = FALSE)
names(std_names_df) <- c('std_source', 'std_field')
head(std_names_df) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

### Loop over rows of `trans_dict` to standardize field names

`trans_dict` is just a df of the spreadsheet `WIP__translation_dictionary.xlsx`. From this, we'll grab first the UDS 3 New field name; if that doesn't exist, we'll grab the UDS 3 Archive field name; if that doesn't exist, it'll be the UDS 2 field name.

From this process is born the standard translation dictionary, `trans_dict_std`.

```{r}
## Loop through rows of `trans_dict`
for (i in seq_len(nrow(trans_dict))) {
  
  ## Std field name is from UDS 3 (New), then UDS 3 (Archive), then UDS 2
  if (!is.na(trans_dict[i, 'field_u3n'])) {
    std_names_df[i, ] <- list('field_u3n', trans_dict[[i, 'field_u3n']])
  } else if (!is.na(trans_dict[i, 'field_u3a'])) {
    std_names_df[i, ] <- list('field_u3a', trans_dict[[i, 'field_u3a']])
  } else if (!is.na(trans_dict[i, 'field_u2'])) {
    std_names_df[i, ] <- list('field_u2', trans_dict[[i, 'field_u2']])
  }
  
}
trans_dict_std <- cbind(trans_dict, std_names_df)
trans_dict_std %>% 
  select(-form_u2, -form_u3a, -form_u3n, 
         -Accounted_For, -Flag, -Matcher,
         -std_field) %>% 
  head() %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

### Append `fu_*` and `tele_*` fields to bottom of Standard Translation Dictionary

This chunk uses data from human-created/-maintained `WIP__uds3_ift_matches.xlsx` to append `fu_*` and `tele_*` fields to the bottom of the Standard Translation Dictionary (which started out as human-created/-maintained `WIP__translation_dictionary.xlsx`).

```{r}
## Append `fu_*` fields ----
u3n_ift_match_f <- u3n_ift_match %>%
  filter(!is.na(field_fvp)) %>%
  filter(field_ivp %in% u3n_fvp_vars) %>%
  pull(field_ivp)
for (i in seq_along(u3n_ift_match_f)) {
  # cat(paste(i, u3n_ift_match_f[i], '\n'))
  # cat(paste(i, nrow(trans_dict_std)+i, '\n'))
  curr_row <- nrow(trans_dict_std) + 1
  ## Add `fu_*` field from within trans_dict_std to end of trans_dict_std
  ## UDS 2
  trans_dict_std[curr_row, 'field_u2'] <-
    paste0('fu_',
           trans_dict_std[[
             which(trans_dict_std$field_u3n == u3n_ift_match_f[i]), 'field_u2'
             ]])
  # UDS 3 (Archive)
  trans_dict_std[curr_row, 'field_u3a'] <-
    paste0('fu_',
           trans_dict_std[[
             which(trans_dict_std$field_u3n == u3n_ift_match_f[i]), 'field_u3a'
             ]])
  # UDS 3 (New)
  trans_dict_std[curr_row, 'field_u3n'] <-
    paste0('fu_',
           trans_dict_std[[
             which(trans_dict_std$field_u3n == u3n_ift_match_f[i]), 'field_u3n'
             ]])
  trans_dict_std[curr_row, 'form_u3n'] <-
    str_replace(
      trans_dict_std[[
        which(trans_dict_std$field_u3n == u3n_ift_match_f[i]), 'form_u3n'
        ]],
      pattern = 'ivp_',
      replacement = 'fvp_')
  trans_dict_std[curr_row, 'Notes'] <-
    '__ synthetic field in UDS 2, UDS 3 (Archive) __'
  trans_dict_std[curr_row, 'std_source'] <- 'field_u3n'
  trans_dict_std[curr_row, 'std_field'] <-
    trans_dict_std[[curr_row, 'field_u3n']]
}
tail(trans_dict_std) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

```{r}
## Append `tele_*` fields ----
u3n_ift_match_t <- u3n_ift_match %>%
  filter(!is.na(field_tvp)) %>%
  filter(field_ivp %in% u3n_tvp_vars) %>%
  pull(field_ivp)
for (i in seq_along(u3n_ift_match_t)) {
  # cat(paste(i, u3n_ift_match_t[i], '\n'))
  # cat(paste(i, nrow(trans_dict_std)+i, '\n'))
  curr_row <- nrow(trans_dict_std) + 1
  ## Add `tele_*` field from within trans_dict_std to end of trans_dict_std
  ## UDS 2
  trans_dict_std[curr_row, 'field_u2'] <-
    paste0('tele_',
           trans_dict_std[[
             which(trans_dict_std$field_u3n == u3n_ift_match_t[i]), 'field_u2'
             ]])
  # UDS 3 (Archive)
  trans_dict_std[curr_row, 'field_u3a'] <-
    paste0('tele_',
           trans_dict_std[[
             which(trans_dict_std$field_u3n == u3n_ift_match_t[i]), 'field_u3a'
             ]])
  # UDS 3 (New)
  trans_dict_std[curr_row, 'field_u3n'] <-
    paste0('tele_',
           trans_dict_std[[
             which(trans_dict_std$field_u3n == u3n_ift_match_t[i]), 'field_u3n'
             ]])
  trans_dict_std[curr_row, 'form_u3n'] <-
    str_replace(
      trans_dict_std[[
        which(trans_dict_std$field_u3n == u3n_ift_match_t[i]), 'form_u3n'
        ]],
      pattern = 'ivp_',
      replacement = 'tvp_')
  trans_dict_std[curr_row, 'Notes'] <-
    '__ synthetic field in UDS 2, UDS 3 (Archive) __'
  trans_dict_std[curr_row, 'std_source'] <- 'field_u3n'
  trans_dict_std[curr_row, 'std_field'] <-
    trans_dict_std[[curr_row, 'field_u3n']]
}
tail(trans_dict_std) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

Now remove any instances of non-existing field names after `fu_*` and `tele_*` preprends.

```{r}
# _ Remove any instances of 'fu_NA', 'tele_NA', 'fu_', 'tele_' -----
trans_dict_std <- trans_dict_std %>% na_if('fu_NA')
trans_dict_std <- trans_dict_std %>% na_if('tele_NA')
trans_dict_std <- trans_dict_std %>% na_if('fu_')
trans_dict_std <- trans_dict_std %>% na_if('tele_')
tail(trans_dict_std) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)
```

## Build Stitched DF (`df_u2_u3a_u3n`)

### Create empty df

```{r}
# _ Build stitched data df ----
## Stitched df is `df_u2_u3a_u3n`
df_u2_u3a_u3n <- data.frame(matrix(data = NA_character_,
                                   nrow = sum(nrow(df_u2_ift),
                                              nrow(df_u3a_ift),
                                              nrow(df_u3n)),
                                   ncol = nrow(trans_dict_std)))
names(df_u2_u3a_u3n) <- trans_dict_std$std_field
```

### Build `df_u2_u3a_u3n`

To accomplish this, we iterate over the rows of `trans_dict_std` and build `df_u2_u3a_u3n` column by column.

```{r}
# Loop through `trans_dict_std` rows to build stitched df column by column
## ... using df_u2_ift, df_u3a_ift, df_u3n
cat("Number of columns in df_u2_u3a_u3n df:\n")
for (i in seq_len(nrow(trans_dict_std))) {
  # for (i in 1:601) {
  cat(paste0(i, ' '))
  
  ## Build temp UDS 2 vector
  if (!is.na(trans_dict_std[i, 'field_u2']) &&
      !is.null(df_u2_ift[[trans_dict_std[i, 'field_u2']]])) {
    temp_u2_vec <- df_u2_ift[[trans_dict_std[i, 'field_u2']]]
  } else {
    temp_u2_vec <- rep(NA_character_, times = nrow(df_u2_ift))
  }
  
  ## Build temp UDS 3 (Archive) vector
  if (!is.na(trans_dict_std[i, 'field_u3a']) &&
      !is.null(df_u3a_ift[[trans_dict_std[i, 'field_u3a']]])) {
    temp_u3a_vec <- df_u3a_ift[[trans_dict_std[i, 'field_u3a']]]
  } else {
    temp_u3a_vec <- rep(NA_character_, times = nrow(df_u3a_ift))
  }
  
  ## Build temp UDS 3 (New) vector
  if (!is.na(trans_dict_std[i, 'field_u3n']) &&
      !is.null(df_u3n[[trans_dict_std[i, 'field_u3n']]])) {
    temp_u3n_vec <- df_u3n[[trans_dict_std[i, 'field_u3n']]]
  } else {
    temp_u3n_vec <- rep(NA_character_, times = nrow(df_u3n))
  }
  
  ## Concat `temp_*_vec` vectors
  temp_u2_u3a_u3n_vec <- c(temp_u2_vec, temp_u3a_vec, temp_u3n_vec)
  # print(length(temp_u2_u3a_u3n_vec))
  
  ## Lay concat'd `temp_*_vec` vectors into stitched df column
  df_u2_u3a_u3n[, i] <- temp_u2_u3a_u3n_vec
}
```

### Reduce the size of `df_u2_u3a_u3n` by guessing column data types

```{r}
print(object.size(df_u2_u3a_u3n), units = 'auto')
# _ Guess column types
df_u2_u3a_u3n <- suppressMessages( readr::type_convert(df_u2_u3a_u3n) )
print(object.size(df_u2_u3a_u3n), units = 'auto')
```

## Write Harmonized Data To CSV

Write the resulting harmonized dataset `df_u2_u3a_u3n` to a CSV file of the same name.

```{r}
# WRITE TO CSV ----
readr::write_csv(df_u2_u3a_u3n, 'df_u2_u3a_u3n.csv', na = '')
```


# Build Data Dictionary

## Get UDS Fields

### UDS 2
```{r}
# UDS 2
data_dict_fields_u2_raw <- trans_dict_std %>% 
  select(std_source, std_field) %>% 
  filter(std_source == 'field_u2') %>% 
  pull(std_field)
```

### UDS 3 Archive
```{r}
# UDS 3 (Archive)
data_dict_fields_u3a_raw <- trans_dict_std %>% 
  select(std_source, std_field) %>% 
  filter(std_source == 'field_u3a') %>% 
  pull(std_field)
```

### UDS 3 New
```{r}
# UDS 3 (New)
data_dict_fields_u3n_raw <- trans_dict_std %>% 
  select(std_source, std_field) %>% 
  filter(std_source == 'field_u3n') %>% 
  pull(std_field)
```

## Retrieve Data Dictionary via REDCap API

### UDS 2
```{r}
json_data_dict_u2 <- RCurl::postForm(
  uri=REDCAP_API_URI,
  token=REDCAP_API_TOKEN_UDS2,
  content='metadata',
  format='json',
  returnFormat='json',
  .opts = list(ssl.verifypeer = FALSE) # using linux
)
df_data_dict_u2_all <- jsonlite::fromJSON(json_data_dict_u2)
df_data_dict_u2 <- df_data_dict_u2_all %>% 
  filter(field_name %in% data_dict_fields_u2_raw)
```

### UDS 3 (Archive)
```{r}
json_data_dict_u3a <- RCurl::postForm(
  uri=REDCAP_API_URI,
  token=REDCAP_API_TOKEN_UDS3a,
  content='metadata',
  format='json',
  returnFormat='json',
  .opts = list(ssl.verifypeer = FALSE) # using linux
)
df_data_dict_u3a_all <- jsonlite::fromJSON(json_data_dict_u3a)
df_data_dict_u3a <- df_data_dict_u3a_all %>% 
  filter(field_name %in% data_dict_fields_u3a_raw)
```

### UDS 3 (New)
```{r}
json_data_dict_u3n <- RCurl::postForm(
  uri=REDCAP_API_URI,
  token=REDCAP_API_TOKEN_UDS3n,
  content='metadata',
  format='json',
  returnFormat='json',
  .opts = list(ssl.verifypeer = FALSE) # using linux
)
df_data_dict_u3n_all <- jsonlite::fromJSON(json_data_dict_u3n)
df_data_dict_u3n <- df_data_dict_u3n_all %>% 
  filter(field_name %in% data_dict_fields_u3n_raw)
```

## Rowbind Data Dictionaries & Order

Order by form name, then field name.

```{r}
df_data_dict <- bind_rows(df_data_dict_u2,
                          df_data_dict_u3a,
                          df_data_dict_u3n)
df_data_dict_form <- df_data_dict %>% 
  arrange(form_name, field_name)
# df_data_dict_field <- df_data_dict %>% 
#   arrange(field_name)

head(df_data_dict_form) %>% 
  select(field_name, form_name, section_header, field_type, field_label,
         select_choices_or_calculations, field_note) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
    font_size = 9)

# head(df_data_dict_field) %>% 
#   kable() %>% 
#   kable_styling(
#     bootstrap_options = c("striped", "hover", "condensed", "responsive"), 
#     font_size = 9)
```

## Write Harmonized Unified Data Dictionary To CSV

```{r}
readr::write_csv(df_data_dict_form, 'df_data_dict_form.csv', na = '')
# readr::write_csv(df_data_dict_field, 'df_data_dict_field.csv', na = '')
```


```{r echo=FALSE}
###@    #==--  :  --==#    @##==---==##@##==---==##@    #==--  :  --==#    @###
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
#  @##==---==##@##==---==##@    EXTRA  :  SPACE    @##==---==##@##==---==##@  #
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
###@    #==--  :  --==#    @##==---==##@##==---==##@    #==--  :  --==#    @###
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
#  @##==---==##@##==---==##@    EXTRA  :  SPACE    @##==---==##@##==---==##@  #
#@##==---==##@   @##==---==##@    #==-- --==#    @##==---==##@   @##==---==##@#
##==---==##@   #   @##==---==##@    #==-==#    @##==---==##@   #   @##==---==##
#=---==##@    #=#    @##==---==##@    #=#    @##==---==##@    #=#    @##==---=#
#--==##@    #==-==#    @##==---==##@   #   @##==---==##@    #==-==#    @##==--#
#==##@    #==-- --==#    @##==---==##@   @##==---==##@    #==-- --==#    @##==#
###@    #==--  :  --==#    @##==---==##@##==---==##@    #==--  :  --==#    @###
```
